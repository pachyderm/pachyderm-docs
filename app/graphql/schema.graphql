# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

directive @defaultOverride(
    "List of arguments for which the defaults should be overridden. Currently only supports 'stage' and 'locales'."
    args: [String!]!
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @mark(
    "Marks an aggregate type"
    aggregate: Boolean,
    "Specifies ConnectInput type name"
    connectInput: String,
    "Link to the Main type of the connection"
    connection: String,
    "Marks a countable type"
    countable: Boolean,
    "Specifies model create input type"
    createInputType: String,
    "Specifies model create localization type"
    createLocalizationInputType: String,
    "Specifies system createdAt field"
    createdAtField: String,
    "Marks if value is default"
    default: Boolean,
    "Marks document version field on Query"
    documentVersion: Boolean,
    "Marks an edge type"
    edge: Boolean,
    "Specifies GraphCMS field type"
    fieldType: String,
    "Marks filter and links to parent type"
    filter: String,
    "Marks if corresponding field is list"
    filterIsList: Boolean,
    "Marks filter kind"
    filterKind: _FilterKind,
    "marks if type is a component"
    isComponent: Boolean,
    "Specifies whether type is connect input"
    isConnectInput: Boolean,
    "Marks list richText field return type"
    isListRichText: Boolean,
    "Specifies relation input to be for abstract member type, not known master / origin side"
    isMemberInput: Boolean,
    "marks if a input type allows to set position in addition to data"
    isPositionInput: Boolean,
    "marks if field is required (non-null)"
    isRequired: Boolean,
    "Marks richText field return type"
    isRichTextType: Boolean,
    "Marks relation fields that do not have a reverse side counterpart"
    isUnidirectional: Boolean,
    "Marks a locale enum"
    locale: Boolean,
    "Marks localizations field"
    localizations: Boolean,
    "Marks if field is localized"
    localized: Boolean,
    "Specifies model a type is part of"
    model: String,
    "Marks versions field on model"
    modelVersions: Boolean,
    "Marks kind of mutation input field"
    mutationInputFieldKind: _MutationInputFieldKind,
    "Marks type of mutation kind"
    mutationKind: _MutationKind,
    "Marks order by"
    order: Boolean,
    "Marks order direction"
    orderDirection: _OrderDirection,
    "Marks the pageInfo"
    pageInfo: Boolean,
    "Specifies relation input cardinality"
    relationInputCardinality: _RelationInputCardinality,
    "Specifies relation input kind"
    relationInputKind: _RelationInputKind,
    "Specifies relation kind (e.g. union relation or regular field relation)"
    relationKind: _RelationKind,
    "Specifies if the filter's value can be replaced by the current user's id"
    replaceableWithUserId: Boolean,
    "Specifies relation input cardinality of reverse side"
    reverseRelationInputCardinality: _RelationInputCardinality,
    "The name of the associated RichText type"
    richTextType: String,
    "Marks stages field"
    stages: Boolean,
    "The model's storage ID"
    storageId: String,
    "Specifies mode of system DateTime fields"
    systemDateTimeFieldVariation: _SystemDateTimeFieldVariation,
    "main side details of union field on component"
    unionFieldDetailsForVirtualMemberSide: String,
    "Specifies union type name"
    unionType: String,
    "Specifies system updatedAt field"
    updatedAtField: String,
    "Marks asset url handler"
    url: Boolean,
    "Adds field validations"
    validations: String,
    "If versioned, documents of this model will be able to hold this amount of versions per stage"
    versionRetentionCount: Int,
    "If versioned, on publishing versions older than x days will be dropped"
    versionRetentionPeriod: Int,
    "Specifies WhereUniqueInput type name"
    whereUniqueInput: String
) on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION

directive @permission(
    "Policy action names."
    actions: [String!],
    "Policy resource names."
    resources: [String!]
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @psql(
    "postgres column name"
    column: String,
    "Specifies the value used to fill the parent_field column that's used to identify the parent field a component got created for"
    componentParentFieldValue: String,
    "hardcoded postgres id value for enums"
    id: String,
    "Specifies column for system id field"
    idColumn: String,
    "postgres join on name"
    join: String,
    "postgres localization table name"
    localizationTable: String,
    "Specifies columns for union member fields"
    memberColumns: [String!],
    "Specifies column for native sorting for relational fields"
    prio: String,
    "postgres table name"
    table: String,
    "Specifies system updatedAt column"
    updatedAtColumn: String,
    "postgres table name for the versions"
    versionTable: String
) on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION

directive @remote(
    "Flag whether debug options are enabled on a given field or not"
    debugEnabled: Boolean!,
    "list of field storage ids that will be fetched in any case from the content db to make them available for {{doc.*}} template placeholders in headers, parameters etc for the remote call"
    docPlaceholderFields: [String!]!,
    "Flag whether to pass headers that are sent by the client to the remote source or not"
    forwardClientHeaders: Boolean!,
    "JSON path pointing to the entry point type that is defined by the GraphQL Query."
    gqlEntryPointPath: [String!],
    "Operation name of the gqlQuery in case of a remote GraphQL API"
    gqlOperationName: String,
    "GraphQL entry point query that will be used to fetch the remote type in case of a remote GraphQL PI"
    gqlQuery: String,
    "optional headers that will be sent in the remote call"
    headers: Json,
    "HTTP method used to fetch the remote content from"
    method: String!,
    "Which type of api should be called. Currently supported: GRAPHQL, REST"
    sourceType: String!,
    "optional ttl value used for caching"
    ttlInSeconds: Int,
    "url to fetch the remote content from"
    url: String!
) on FIELD_DEFINITION

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
    "The Stage of an object"
    stage: Stage!
}

union ChapterCopyNest = Page

union DemoModelContentRichTextEmbeddedTypes = Asset

union NavItemItem = Chapter | ExternalLink | Page

union PageContentRichTextEmbeddedTypes = Asset | Page

union ScheduledOperationAffectedDocument = Asset | Chapter | ChapterCopy | DemoModel | ExternalLink | Navigation | Page | Seo

type Aggregate {
    count: Int!
}

"Asset system model"
type Asset implements Node {
    "The time the document was created"
    createdAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Asset!]!
    "The file name"
    fileName: String!
    "The file handle"
    handle: String!
    "The height of the file"
    height: Float
    "List of Asset versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    imageSeo(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `imageSeo` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: SeoOrderByInput,
        skip: Int,
        where: SeoWhereInput
    ): [Seo!]!
    "System Locale field"
    locale: Locale!
    "Get the other localizations for this document"
    localizations(
        "Decides if the current locale should be included or not"
        includeCurrent: Boolean! = false,
        "Potential locales that should be returned"
        locales: [Locale!]! = [en]
    ): [Asset!]!
    "The mime type of the file"
    mimeType: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "The file size"
    size: Float
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the url for the asset with provided transformations applied."
    url(transformation: AssetTransformationInput): String!
    "The file width"
    width: Float
}

"A connection to a list of items."
type AssetConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [AssetEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AssetEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Asset!
}

type BatchPayload {
    "The number of nodes that have been affected by the Batch operation."
    count: Long!
}

type Chapter implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Chapter!]!
    "List of Chapter versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    navItem(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `navItem` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Navigation
    pages(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `pages` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: PageOrderByInput,
        skip: Int,
        where: PageWhereInput
    ): [Page!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    slug: String!
    "System stage field"
    stage: Stage!
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ChapterConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ChapterEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

type ChapterCopy implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [ChapterCopy!]!
    "List of ChapterCopy versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    nest(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `nest` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int
    ): [ChapterCopyNest!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    slug: String!
    "System stage field"
    stage: Stage!
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ChapterCopyConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ChapterCopyEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ChapterCopyEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ChapterCopy!
}

"An edge in a connection."
type ChapterEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Chapter!
}

"Representing a color value comprising of HEX, RGBA and css color values"
type Color {
    css: String!
    hex: Hex!
    rgba: RGBA!
}

"This model can be used, for example, as a simple form on a website, app, database with several text fields already added."
type DemoModel implements Node {
    content: DemoModelContentRichText!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [DemoModel!]!
    "List of DemoModel versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    slug: String!
    "System stage field"
    stage: Stage!
    subtitle: String
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type DemoModelConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [DemoModelEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

type DemoModelContentRichText {
    "Returns HTMl representation"
    html: String!
    json: RichTextAST!
    "Returns Markdown representation"
    markdown: String!
    raw: RichTextAST! @deprecated(reason: "Please use the 'json' field")
    references: [DemoModelContentRichTextEmbeddedTypes!]!
    "Returns plain-text contents of RichText"
    text: String!
}

"An edge in a connection."
type DemoModelEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DemoModel!
}

type DocumentVersion {
    createdAt: DateTime!
    data: Json
    id: ID!
    revision: Int!
    stage: Stage!
}

type ExternalLink implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [ExternalLink!]!
    "List of ExternalLink versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    label: String!
    navItem(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `navItem` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Navigation
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    url: String!
}

"A connection to a list of items."
type ExternalLinkConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ExternalLinkEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ExternalLinkEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ExternalLink!
}

"Representing a geolocation point with latitude and longitude"
type Location {
    distance(from: LocationInput!): Float!
    latitude: Float!
    longitude: Float!
}

type Mutation {
    "Create one asset"
    createAsset(data: AssetCreateInput!): Asset @deprecated(reason: "Asset mutations will be overhauled soon")
    "Create one chapter"
    createChapter(data: ChapterCreateInput!): Chapter
    "Create one chapterCopy"
    createChapterCopy(data: ChapterCopyCreateInput!): ChapterCopy
    "Create one demoModel"
    createDemoModel(data: DemoModelCreateInput!): DemoModel
    "Create one externalLink"
    createExternalLink(data: ExternalLinkCreateInput!): ExternalLink
    "Create one navigation"
    createNavigation(data: NavigationCreateInput!): Navigation
    "Create one page"
    createPage(data: PageCreateInput!): Page
    "Create one scheduledRelease"
    createScheduledRelease(data: ScheduledReleaseCreateInput!): ScheduledRelease
    "Create one seo"
    createSeo(data: SeoCreateInput!): Seo
    "Delete one asset from _all_ existing stages. Returns deleted document."
    deleteAsset(
        "Document to delete"
        where: AssetWhereUniqueInput!
    ): Asset
    "Delete one chapter from _all_ existing stages. Returns deleted document."
    deleteChapter(
        "Document to delete"
        where: ChapterWhereUniqueInput!
    ): Chapter
    "Delete one chapterCopy from _all_ existing stages. Returns deleted document."
    deleteChapterCopy(
        "Document to delete"
        where: ChapterCopyWhereUniqueInput!
    ): ChapterCopy
    "Delete one demoModel from _all_ existing stages. Returns deleted document."
    deleteDemoModel(
        "Document to delete"
        where: DemoModelWhereUniqueInput!
    ): DemoModel
    "Delete one externalLink from _all_ existing stages. Returns deleted document."
    deleteExternalLink(
        "Document to delete"
        where: ExternalLinkWhereUniqueInput!
    ): ExternalLink
    "Delete many Asset documents"
    deleteManyAssets(
        "Documents to delete"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyAssetsConnection)")
    "Delete many Asset documents, return deleted documents"
    deleteManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Delete many Chapter documents"
    deleteManyChapters(
        "Documents to delete"
        where: ChapterManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyChaptersConnection)")
    "Delete many Chapter documents, return deleted documents"
    deleteManyChaptersConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: ChapterManyWhereInput
    ): ChapterConnection!
    "Delete many ChapterCopy documents"
    deleteManyChaptersCopy(
        "Documents to delete"
        where: ChapterCopyManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyChaptersCopyConnection)")
    "Delete many ChapterCopy documents, return deleted documents"
    deleteManyChaptersCopyConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: ChapterCopyManyWhereInput
    ): ChapterCopyConnection!
    "Delete many DemoModel documents"
    deleteManyDemoModels(
        "Documents to delete"
        where: DemoModelManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyDemoModelsConnection)")
    "Delete many DemoModel documents, return deleted documents"
    deleteManyDemoModelsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: DemoModelManyWhereInput
    ): DemoModelConnection!
    "Delete many ExternalLink documents"
    deleteManyExternalLinks(
        "Documents to delete"
        where: ExternalLinkManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyExternalLinksConnection)")
    "Delete many ExternalLink documents, return deleted documents"
    deleteManyExternalLinksConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: ExternalLinkManyWhereInput
    ): ExternalLinkConnection!
    "Delete many Navigation documents"
    deleteManyNavigations(
        "Documents to delete"
        where: NavigationManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyNavigationsConnection)")
    "Delete many Navigation documents, return deleted documents"
    deleteManyNavigationsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: NavigationManyWhereInput
    ): NavigationConnection!
    "Delete many Page documents"
    deleteManyPages(
        "Documents to delete"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyPagesConnection)")
    "Delete many Page documents, return deleted documents"
    deleteManyPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: PageManyWhereInput
    ): PageConnection!
    "Delete many Seo documents"
    deleteManySeos(
        "Documents to delete"
        where: SeoManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManySeosConnection)")
    "Delete many Seo documents, return deleted documents"
    deleteManySeosConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: SeoManyWhereInput
    ): SeoConnection!
    "Delete one navigation from _all_ existing stages. Returns deleted document."
    deleteNavigation(
        "Document to delete"
        where: NavigationWhereUniqueInput!
    ): Navigation
    "Delete one page from _all_ existing stages. Returns deleted document."
    deletePage(
        "Document to delete"
        where: PageWhereUniqueInput!
    ): Page
    "Delete and return scheduled operation"
    deleteScheduledOperation(
        "Document to delete"
        where: ScheduledOperationWhereUniqueInput!
    ): ScheduledOperation
    "Delete one scheduledRelease from _all_ existing stages. Returns deleted document."
    deleteScheduledRelease(
        "Document to delete"
        where: ScheduledReleaseWhereUniqueInput!
    ): ScheduledRelease
    "Delete one seo from _all_ existing stages. Returns deleted document."
    deleteSeo(
        "Document to delete"
        where: SeoWhereUniqueInput!
    ): Seo
    "Publish one asset"
    publishAsset(
        "Optional localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: AssetWhereUniqueInput!,
        "Whether to include the default locale when publishBase is set"
        withDefaultLocale: Boolean = true
    ): Asset
    "Publish one chapter"
    publishChapter(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ChapterWhereUniqueInput!
    ): Chapter
    "Publish one chapterCopy"
    publishChapterCopy(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ChapterCopyWhereUniqueInput!
    ): ChapterCopy
    "Publish one demoModel"
    publishDemoModel(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: DemoModelWhereUniqueInput!
    ): DemoModel
    "Publish one externalLink"
    publishExternalLink(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ExternalLinkWhereUniqueInput!
    ): ExternalLink
    "Publish many Asset documents"
    publishManyAssets(
        "Document localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: AssetManyWhereInput,
        "Whether to include the default locale when publishBase is true"
        withDefaultLocale: Boolean = true
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyAssetsConnection)")
    "Publish many Asset documents"
    publishManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        "Document localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: AssetManyWhereInput,
        "Whether to include the default locale when publishBase is true"
        withDefaultLocale: Boolean = true
    ): AssetConnection!
    "Publish many Chapter documents"
    publishManyChapters(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ChapterManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyChaptersConnection)")
    "Publish many Chapter documents"
    publishManyChaptersConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ChapterManyWhereInput
    ): ChapterConnection!
    "Publish many ChapterCopy documents"
    publishManyChaptersCopy(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ChapterCopyManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyChaptersCopyConnection)")
    "Publish many ChapterCopy documents"
    publishManyChaptersCopyConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ChapterCopyManyWhereInput
    ): ChapterCopyConnection!
    "Publish many DemoModel documents"
    publishManyDemoModels(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: DemoModelManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyDemoModelsConnection)")
    "Publish many DemoModel documents"
    publishManyDemoModelsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: DemoModelManyWhereInput
    ): DemoModelConnection!
    "Publish many ExternalLink documents"
    publishManyExternalLinks(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ExternalLinkManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyExternalLinksConnection)")
    "Publish many ExternalLink documents"
    publishManyExternalLinksConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ExternalLinkManyWhereInput
    ): ExternalLinkConnection!
    "Publish many Navigation documents"
    publishManyNavigations(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: NavigationManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyNavigationsConnection)")
    "Publish many Navigation documents"
    publishManyNavigationsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: NavigationManyWhereInput
    ): NavigationConnection!
    "Publish many Page documents"
    publishManyPages(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyPagesConnection)")
    "Publish many Page documents"
    publishManyPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: PageManyWhereInput
    ): PageConnection!
    "Publish many Seo documents"
    publishManySeos(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: SeoManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManySeosConnection)")
    "Publish many Seo documents"
    publishManySeosConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: SeoManyWhereInput
    ): SeoConnection!
    "Publish one navigation"
    publishNavigation(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: NavigationWhereUniqueInput!
    ): Navigation
    "Publish one page"
    publishPage(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: PageWhereUniqueInput!
    ): Page
    "Publish one seo"
    publishSeo(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: SeoWhereUniqueInput!
    ): Seo
    "Schedule to publish one asset"
    schedulePublishAsset(
        "Optional localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: AssetWhereUniqueInput!,
        "Whether to include the default locale when publishBase is set"
        withDefaultLocale: Boolean = true
    ): Asset
    "Schedule to publish one chapter"
    schedulePublishChapter(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ChapterWhereUniqueInput!
    ): Chapter
    "Schedule to publish one chapterCopy"
    schedulePublishChapterCopy(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ChapterCopyWhereUniqueInput!
    ): ChapterCopy
    "Schedule to publish one demoModel"
    schedulePublishDemoModel(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: DemoModelWhereUniqueInput!
    ): DemoModel
    "Schedule to publish one externalLink"
    schedulePublishExternalLink(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ExternalLinkWhereUniqueInput!
    ): ExternalLink
    "Schedule to publish one navigation"
    schedulePublishNavigation(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: NavigationWhereUniqueInput!
    ): Navigation
    "Schedule to publish one page"
    schedulePublishPage(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: PageWhereUniqueInput!
    ): Page
    "Schedule to publish one seo"
    schedulePublishSeo(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: SeoWhereUniqueInput!
    ): Seo
    "Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishAsset(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Optional locales to unpublish. Unpublishing the default locale will completely remove the document from the selected stages"
        locales: [Locale!],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Unpublish complete document including default localization and relations from stages. Can be disabled."
        unpublishBase: Boolean = true,
        "Document to unpublish"
        where: AssetWhereUniqueInput!
    ): Asset
    "Unpublish one chapter from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishChapter(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: ChapterWhereUniqueInput!
    ): Chapter
    "Unpublish one chapterCopy from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishChapterCopy(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: ChapterCopyWhereUniqueInput!
    ): ChapterCopy
    "Unpublish one demoModel from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishDemoModel(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: DemoModelWhereUniqueInput!
    ): DemoModel
    "Unpublish one externalLink from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishExternalLink(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: ExternalLinkWhereUniqueInput!
    ): ExternalLink
    "Unpublish one navigation from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishNavigation(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: NavigationWhereUniqueInput!
    ): Navigation
    "Unpublish one page from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishPage(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: PageWhereUniqueInput!
    ): Page
    "Unpublish one seo from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishSeo(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: SeoWhereUniqueInput!
    ): Seo
    "Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishAsset(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Optional locales to unpublish. Unpublishing the default locale will completely remove the document from the selected stages"
        locales: [Locale!],
        "Unpublish complete document including default localization and relations from stages. Can be disabled."
        unpublishBase: Boolean = true,
        "Document to unpublish"
        where: AssetWhereUniqueInput!
    ): Asset
    "Unpublish one chapter from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishChapter(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: ChapterWhereUniqueInput!
    ): Chapter
    "Unpublish one chapterCopy from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishChapterCopy(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: ChapterCopyWhereUniqueInput!
    ): ChapterCopy
    "Unpublish one demoModel from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishDemoModel(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: DemoModelWhereUniqueInput!
    ): DemoModel
    "Unpublish one externalLink from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishExternalLink(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: ExternalLinkWhereUniqueInput!
    ): ExternalLink
    "Unpublish many Asset documents"
    unpublishManyAssets(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Locales to unpublish"
        locales: [Locale!],
        "Whether to unpublish the base document and default localization"
        unpublishBase: Boolean = true,
        "Identifies documents in each stage"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyAssetsConnection)")
    "Find many Asset documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        "Locales to unpublish"
        locales: [Locale!],
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Whether to unpublish the base document and default localization"
        unpublishBase: Boolean = true,
        "Identifies documents in draft stage"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Unpublish many Chapter documents"
    unpublishManyChapters(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: ChapterManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyChaptersConnection)")
    "Find many Chapter documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyChaptersConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: ChapterManyWhereInput
    ): ChapterConnection!
    "Unpublish many ChapterCopy documents"
    unpublishManyChaptersCopy(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: ChapterCopyManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyChaptersCopyConnection)")
    "Find many ChapterCopy documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyChaptersCopyConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: ChapterCopyManyWhereInput
    ): ChapterCopyConnection!
    "Unpublish many DemoModel documents"
    unpublishManyDemoModels(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: DemoModelManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyDemoModelsConnection)")
    "Find many DemoModel documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyDemoModelsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: DemoModelManyWhereInput
    ): DemoModelConnection!
    "Unpublish many ExternalLink documents"
    unpublishManyExternalLinks(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: ExternalLinkManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyExternalLinksConnection)")
    "Find many ExternalLink documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyExternalLinksConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: ExternalLinkManyWhereInput
    ): ExternalLinkConnection!
    "Unpublish many Navigation documents"
    unpublishManyNavigations(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: NavigationManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyNavigationsConnection)")
    "Find many Navigation documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyNavigationsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: NavigationManyWhereInput
    ): NavigationConnection!
    "Unpublish many Page documents"
    unpublishManyPages(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyPagesConnection)")
    "Find many Page documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: PageManyWhereInput
    ): PageConnection!
    "Unpublish many Seo documents"
    unpublishManySeos(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: SeoManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManySeosConnection)")
    "Find many Seo documents that match criteria in specified stage and unpublish from target stages"
    unpublishManySeosConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: SeoManyWhereInput
    ): SeoConnection!
    "Unpublish one navigation from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishNavigation(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: NavigationWhereUniqueInput!
    ): Navigation
    "Unpublish one page from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishPage(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: PageWhereUniqueInput!
    ): Page
    "Unpublish one seo from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishSeo(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: SeoWhereUniqueInput!
    ): Seo
    "Update one asset"
    updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
    "Update one chapter"
    updateChapter(data: ChapterUpdateInput!, where: ChapterWhereUniqueInput!): Chapter
    "Update one chapterCopy"
    updateChapterCopy(data: ChapterCopyUpdateInput!, where: ChapterCopyWhereUniqueInput!): ChapterCopy
    "Update one demoModel"
    updateDemoModel(data: DemoModelUpdateInput!, where: DemoModelWhereUniqueInput!): DemoModel
    "Update one externalLink"
    updateExternalLink(data: ExternalLinkUpdateInput!, where: ExternalLinkWhereUniqueInput!): ExternalLink
    "Update many assets"
    updateManyAssets(
        "Updates to document content"
        data: AssetUpdateManyInput!,
        "Documents to apply update on"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyAssetsConnection)")
    "Update many Asset documents"
    updateManyAssetsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: AssetUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Update many chapters"
    updateManyChapters(
        "Updates to document content"
        data: ChapterUpdateManyInput!,
        "Documents to apply update on"
        where: ChapterManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyChaptersConnection)")
    "Update many Chapter documents"
    updateManyChaptersConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: ChapterUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: ChapterManyWhereInput
    ): ChapterConnection!
    "Update many chaptersCopy"
    updateManyChaptersCopy(
        "Updates to document content"
        data: ChapterCopyUpdateManyInput!,
        "Documents to apply update on"
        where: ChapterCopyManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyChaptersCopyConnection)")
    "Update many ChapterCopy documents"
    updateManyChaptersCopyConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: ChapterCopyUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: ChapterCopyManyWhereInput
    ): ChapterCopyConnection!
    "Update many demoModels"
    updateManyDemoModels(
        "Updates to document content"
        data: DemoModelUpdateManyInput!,
        "Documents to apply update on"
        where: DemoModelManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyDemoModelsConnection)")
    "Update many DemoModel documents"
    updateManyDemoModelsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: DemoModelUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: DemoModelManyWhereInput
    ): DemoModelConnection!
    "Update many externalLinks"
    updateManyExternalLinks(
        "Updates to document content"
        data: ExternalLinkUpdateManyInput!,
        "Documents to apply update on"
        where: ExternalLinkManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyExternalLinksConnection)")
    "Update many ExternalLink documents"
    updateManyExternalLinksConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: ExternalLinkUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: ExternalLinkManyWhereInput
    ): ExternalLinkConnection!
    "Update many navigations"
    updateManyNavigations(
        "Updates to document content"
        data: NavigationUpdateManyInput!,
        "Documents to apply update on"
        where: NavigationManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyNavigationsConnection)")
    "Update many Navigation documents"
    updateManyNavigationsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: NavigationUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: NavigationManyWhereInput
    ): NavigationConnection!
    "Update many pages"
    updateManyPages(
        "Updates to document content"
        data: PageUpdateManyInput!,
        "Documents to apply update on"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyPagesConnection)")
    "Update many Page documents"
    updateManyPagesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: PageUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: PageManyWhereInput
    ): PageConnection!
    "Update many seos"
    updateManySeos(
        "Updates to document content"
        data: SeoUpdateManyInput!,
        "Documents to apply update on"
        where: SeoManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManySeosConnection)")
    "Update many Seo documents"
    updateManySeosConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: SeoUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: SeoManyWhereInput
    ): SeoConnection!
    "Update one navigation"
    updateNavigation(data: NavigationUpdateInput!, where: NavigationWhereUniqueInput!): Navigation
    "Update one page"
    updatePage(data: PageUpdateInput!, where: PageWhereUniqueInput!): Page
    "Update one scheduledRelease"
    updateScheduledRelease(data: ScheduledReleaseUpdateInput!, where: ScheduledReleaseWhereUniqueInput!): ScheduledRelease
    "Update one seo"
    updateSeo(data: SeoUpdateInput!, where: SeoWhereUniqueInput!): Seo
    "Upsert one asset"
    upsertAsset(upsert: AssetUpsertInput!, where: AssetWhereUniqueInput!): Asset
    "Upsert one chapter"
    upsertChapter(upsert: ChapterUpsertInput!, where: ChapterWhereUniqueInput!): Chapter
    "Upsert one chapterCopy"
    upsertChapterCopy(upsert: ChapterCopyUpsertInput!, where: ChapterCopyWhereUniqueInput!): ChapterCopy
    "Upsert one demoModel"
    upsertDemoModel(upsert: DemoModelUpsertInput!, where: DemoModelWhereUniqueInput!): DemoModel
    "Upsert one externalLink"
    upsertExternalLink(upsert: ExternalLinkUpsertInput!, where: ExternalLinkWhereUniqueInput!): ExternalLink
    "Upsert one navigation"
    upsertNavigation(upsert: NavigationUpsertInput!, where: NavigationWhereUniqueInput!): Navigation
    "Upsert one page"
    upsertPage(upsert: PageUpsertInput!, where: PageWhereUniqueInput!): Page
    "Upsert one seo"
    upsertSeo(upsert: SeoUpsertInput!, where: SeoWhereUniqueInput!): Seo
}

type Navigation implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Navigation!]!
    "List of Navigation versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    linkTo(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `linkTo` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int
    ): [NavItemItem!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type NavigationConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [NavigationEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type NavigationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Navigation!
}

type Page implements Node {
    chapter(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `chapter` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Chapter
    chapters(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `chapters` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ChapterCopyWhereInput
    ): [ChapterCopy!]!
    content: PageContentRichText
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Page!]!
    "List of Page versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    navItem(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `navItem` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Navigation
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    seo(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `seo` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Seo
    slug: String!
    "System stage field"
    stage: Stage!
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type PageConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [PageEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

type PageContentRichText {
    "Returns HTMl representation"
    html: String!
    json: RichTextAST!
    "Returns Markdown representation"
    markdown: String!
    raw: RichTextAST! @deprecated(reason: "Please use the 'json' field")
    references: [PageContentRichTextEmbeddedTypes!]!
    "Returns plain-text contents of RichText"
    text: String!
}

"An edge in a connection."
type PageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Page!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Number of items in the current page."
    pageSize: Int
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Query {
    "Retrieve a single asset"
    asset(
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: AssetWhereUniqueInput!
    ): Asset
    "Retrieve document version"
    assetVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple assets"
    assets(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): [Asset!]!
    "Retrieve multiple assets using the Relay connection interface"
    assetsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): AssetConnection!
    "Retrieve a single chapter"
    chapter(
        """

        Defines which locales should be returned.

        Note that `Chapter` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ChapterWhereUniqueInput!
    ): Chapter
    "Retrieve a single chapterCopy"
    chapterCopy(
        """

        Defines which locales should be returned.

        Note that `ChapterCopy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ChapterCopyWhereUniqueInput!
    ): ChapterCopy
    "Retrieve document version"
    chapterCopyVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve document version"
    chapterVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple chapters"
    chapters(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Chapter` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ChapterOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ChapterWhereInput
    ): [Chapter!]!
    "Retrieve multiple chapters using the Relay connection interface"
    chaptersConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Chapter` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ChapterOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ChapterWhereInput
    ): ChapterConnection!
    "Retrieve multiple chaptersCopy"
    chaptersCopy(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ChapterCopy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ChapterCopyOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ChapterCopyWhereInput
    ): [ChapterCopy!]!
    "Retrieve multiple chaptersCopy using the Relay connection interface"
    chaptersCopyConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ChapterCopy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ChapterCopyOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ChapterCopyWhereInput
    ): ChapterCopyConnection!
    "Retrieve a single demoModel"
    demoModel(
        """

        Defines which locales should be returned.

        Note that `DemoModel` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: DemoModelWhereUniqueInput!
    ): DemoModel
    "Retrieve document version"
    demoModelVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple demoModels"
    demoModels(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `DemoModel` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: DemoModelOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: DemoModelWhereInput
    ): [DemoModel!]!
    "Retrieve multiple demoModels using the Relay connection interface"
    demoModelsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `DemoModel` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: DemoModelOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: DemoModelWhereInput
    ): DemoModelConnection!
    "Retrieve a single externalLink"
    externalLink(
        """

        Defines which locales should be returned.

        Note that `ExternalLink` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ExternalLinkWhereUniqueInput!
    ): ExternalLink
    "Retrieve document version"
    externalLinkVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple externalLinks"
    externalLinks(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ExternalLink` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ExternalLinkOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ExternalLinkWhereInput
    ): [ExternalLink!]!
    "Retrieve multiple externalLinks using the Relay connection interface"
    externalLinksConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ExternalLink` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ExternalLinkOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ExternalLinkWhereInput
    ): ExternalLinkConnection!
    "Retrieve a single navigation"
    navigation(
        """

        Defines which locales should be returned.

        Note that `Navigation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: NavigationWhereUniqueInput!
    ): Navigation
    "Retrieve document version"
    navigationVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple navigations"
    navigations(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Navigation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: NavigationOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: NavigationWhereInput
    ): [Navigation!]!
    "Retrieve multiple navigations using the Relay connection interface"
    navigationsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Navigation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: NavigationOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: NavigationWhereInput
    ): NavigationConnection!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!,
        """

        Defines which locales should be returned.

        Note that `Node` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED
    ): Node
    "Retrieve a single page"
    page(
        """

        Defines which locales should be returned.

        Note that `Page` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: PageWhereUniqueInput!
    ): Page
    "Retrieve document version"
    pageVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple pages"
    pages(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Page` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: PageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: PageWhereInput
    ): [Page!]!
    "Retrieve multiple pages using the Relay connection interface"
    pagesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Page` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: PageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: PageWhereInput
    ): PageConnection!
    "Retrieve a single scheduledOperation"
    scheduledOperation(
        """

        Defines which locales should be returned.

        Note that `ScheduledOperation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ScheduledOperationWhereUniqueInput!
    ): ScheduledOperation
    "Retrieve multiple scheduledOperations"
    scheduledOperations(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledOperation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledOperationOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "Retrieve multiple scheduledOperations using the Relay connection interface"
    scheduledOperationsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledOperation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledOperationOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledOperationWhereInput
    ): ScheduledOperationConnection!
    "Retrieve a single scheduledRelease"
    scheduledRelease(
        """

        Defines which locales should be returned.

        Note that `ScheduledRelease` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ScheduledReleaseWhereUniqueInput!
    ): ScheduledRelease
    "Retrieve multiple scheduledReleases"
    scheduledReleases(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledRelease` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledReleaseOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledReleaseWhereInput
    ): [ScheduledRelease!]!
    "Retrieve multiple scheduledReleases using the Relay connection interface"
    scheduledReleasesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledRelease` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledReleaseOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledReleaseWhereInput
    ): ScheduledReleaseConnection!
    "Retrieve a single seo"
    seo(
        """

        Defines which locales should be returned.

        Note that `Seo` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: SeoWhereUniqueInput!
    ): Seo
    "Retrieve document version"
    seoVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple seos"
    seos(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Seo` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: SeoOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: SeoWhereInput
    ): [Seo!]!
    "Retrieve multiple seos using the Relay connection interface"
    seosConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Seo` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: SeoOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: SeoWhereInput
    ): SeoConnection!
    "Retrieve a single user"
    user(
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: UserWhereUniqueInput!
    ): User
    "Retrieve multiple users"
    users(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: UserOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: UserWhereInput
    ): [User!]!
    "Retrieve multiple users using the Relay connection interface"
    usersConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: UserOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: UserWhereInput
    ): UserConnection!
}

"Representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
type RGBA {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

"Custom type representing a rich text value comprising of raw rich text ast, html, markdown and text values"
type RichText {
    "Returns HTMl representation"
    html: String!
    "Returns Markdown representation"
    markdown: String!
    "Returns AST representation"
    raw: RichTextAST!
    "Returns plain-text contents of RichText"
    text: String!
}

"Scheduled Operation system model"
type ScheduledOperation implements Node {
    affectedDocuments(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `affectedDocuments` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int
    ): [ScheduledOperationAffectedDocument!]!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Operation description"
    description: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [ScheduledOperation!]!
    "Operation error message"
    errorMessage: String
    "The unique identifier"
    id: ID!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Raw operation payload including all details, this field is subject to change"
    rawPayload: Json!
    "The release this operation is scheduled for"
    release(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `release` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): ScheduledRelease
    "System stage field"
    stage: Stage!
    "operation Status"
    status: ScheduledOperationStatus!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ScheduledOperationConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ScheduledOperationEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ScheduledOperationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ScheduledOperation!
}

"Scheduled Release system model"
type ScheduledRelease implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Release description"
    description: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [ScheduledRelease!]!
    "Release error message"
    errorMessage: String
    "The unique identifier"
    id: ID!
    "Whether scheduled release should be run"
    isActive: Boolean!
    "Whether scheduled release is implicit"
    isImplicit: Boolean!
    "Operations to run with this release"
    operations(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `operations` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: ScheduledOperationOrderByInput,
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Release date and time"
    releaseAt: DateTime
    "System stage field"
    stage: Stage!
    "Release Status"
    status: ScheduledReleaseStatus!
    "Release Title"
    title: String
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ScheduledReleaseConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ScheduledReleaseEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ScheduledReleaseEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ScheduledRelease!
}

type Seo implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    description: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Seo!]!
    "List of Seo versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    image(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `image` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Asset
    noindex: Boolean
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "System stage field"
    stage: Stage!
    title: String
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type SeoConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [SeoEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type SeoEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Seo!
}

"User system model"
type User implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [User!]!
    "The unique identifier"
    id: ID!
    "Flag to determine if user is active or not"
    isActive: Boolean!
    "User Kind. Can be either MEMBER, PAT or PUBLIC"
    kind: UserKind!
    "The username"
    name: String!
    "Profile Picture url"
    picture: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
}

"A connection to a list of items."
type UserConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [UserEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type Version {
    createdAt: DateTime!
    id: ID!
    revision: Int!
    stage: Stage!
}

enum AssetOrderByInput {
    createdAt_ASC
    createdAt_DESC
    fileName_ASC
    fileName_DESC
    handle_ASC
    handle_DESC
    height_ASC
    height_DESC
    id_ASC
    id_DESC
    mimeType_ASC
    mimeType_DESC
    publishedAt_ASC
    publishedAt_DESC
    size_ASC
    size_DESC
    updatedAt_ASC
    updatedAt_DESC
    width_ASC
    width_DESC
}

enum ChapterCopyOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    slug_ASC
    slug_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum ChapterOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    slug_ASC
    slug_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum DemoModelOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    slug_ASC
    slug_DESC
    subtitle_ASC
    subtitle_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum DocumentFileTypes {
    doc
    docx
    html
    jpg
    odp
    ods
    odt
    pdf
    png
    ppt
    pptx
    svg
    txt
    webp
    xls
    xlsx
}

enum ExternalLinkOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    label_ASC
    label_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    url_ASC
    url_DESC
}

enum ImageFit {
    "Resizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio."
    clip
    "Resizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries."
    crop
    "Resizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size."
    max
    "Resizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method."
    scale
}

"Locale system enumeration"
enum Locale {
    "System locale"
    en
}

enum NavigationOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum PageOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    slug_ASC
    slug_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum ScheduledOperationOrderByInput {
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    errorMessage_ASC
    errorMessage_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    status_ASC
    status_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"System Scheduled Operation Status"
enum ScheduledOperationStatus {
    CANCELED
    COMPLETED
    FAILED
    IN_PROGRESS
    PENDING
}

enum ScheduledReleaseOrderByInput {
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    errorMessage_ASC
    errorMessage_DESC
    id_ASC
    id_DESC
    isActive_ASC
    isActive_DESC
    isImplicit_ASC
    isImplicit_DESC
    publishedAt_ASC
    publishedAt_DESC
    releaseAt_ASC
    releaseAt_DESC
    status_ASC
    status_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"System Scheduled Release Status"
enum ScheduledReleaseStatus {
    COMPLETED
    FAILED
    IN_PROGRESS
    PENDING
}

enum SeoOrderByInput {
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    id_ASC
    id_DESC
    noindex_ASC
    noindex_DESC
    publishedAt_ASC
    publishedAt_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"Stage system enumeration"
enum Stage {
    "The Draft is the default stage for all your content."
    DRAFT
    "The Published stage is where you can publish your content to."
    PUBLISHED
}

enum SystemDateTimeFieldVariation {
    BASE
    COMBINED
    LOCALIZATION
}

enum Tags {
    amd
    arm
    ce
    datums
    docker
    enterprise
    helm
    minikube
    onboarding
    pachctl
    pachd
    pipelines
    setup
}

"System User Kind"
enum UserKind {
    MEMBER
    PAT
    PUBLIC
    WEBHOOK
}

enum UserOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    isActive_ASC
    isActive_DESC
    kind_ASC
    kind_DESC
    name_ASC
    name_DESC
    picture_ASC
    picture_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum _FilterKind {
    AND
    NOT
    OR
    contains
    contains_all
    contains_none
    contains_some
    ends_with
    eq
    eq_not
    gt
    gte
    in
    lt
    lte
    not_contains
    not_ends_with
    not_in
    not_starts_with
    relational_every
    relational_none
    relational_single
    relational_some
    search
    starts_with
}

enum _MutationInputFieldKind {
    enum
    relation
    richText
    richTextWithEmbeds
    scalar
    union
    virtual
}

enum _MutationKind {
    create
    delete
    deleteMany
    publish
    publishMany
    schedulePublish
    scheduleUnpublish
    unpublish
    unpublishMany
    update
    updateMany
    upsert
}

enum _OrderDirection {
    asc
    desc
}

enum _RelationInputCardinality {
    many
    one
}

enum _RelationInputKind {
    create
    update
}

enum _RelationKind {
    regular
    union
}

enum _SystemDateTimeFieldVariation {
    base
    combined
    localization
}

"A date string, such as 2007-12-03 (YYYY-MM-DD), compliant with ISO 8601 standard for representation of dates using the Gregorian calendar."
scalar Date

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the date-timeformat outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representationof dates and times using the Gregorian calendar."
scalar DateTime

scalar Hex

"Raw JSON value"
scalar Json

"The Long scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar RGBAHue

scalar RGBATransparency

"Slate-compatible RichText AST"
scalar RichTextAST

input AssetConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: AssetWhereUniqueInput!
}

input AssetCreateInput {
    createdAt: DateTime
    fileName: String!
    handle: String!
    height: Float
    imageSeo: SeoCreateManyInlineInput
    "Inline mutations for managing document localizations excluding the default locale"
    localizations: AssetCreateLocalizationsInput
    mimeType: String
    size: Float
    updatedAt: DateTime
    width: Float
}

input AssetCreateLocalizationDataInput {
    createdAt: DateTime
    fileName: String!
    handle: String!
    height: Float
    mimeType: String
    size: Float
    updatedAt: DateTime
    width: Float
}

input AssetCreateLocalizationInput {
    "Localization input"
    data: AssetCreateLocalizationDataInput!
    locale: Locale!
}

input AssetCreateLocalizationsInput {
    "Create localizations for the newly-created document"
    create: [AssetCreateLocalizationInput!]
}

input AssetCreateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetWhereUniqueInput!]
    "Create and connect multiple existing Asset documents"
    create: [AssetCreateInput!]
}

input AssetCreateOneInlineInput {
    "Connect one existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
}

"Identifies documents"
input AssetManyWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    imageSeo_every: SeoWhereInput
    imageSeo_none: SeoWhereInput
    imageSeo_some: SeoWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"Transformations for Assets"
input AssetTransformationInput {
    document: DocumentTransformationInput
    image: ImageTransformationInput
    "Pass true if you want to validate the passed transformation parameters"
    validateOptions: Boolean = false
}

input AssetUpdateInput {
    fileName: String
    handle: String
    height: Float
    imageSeo: SeoUpdateManyInlineInput
    "Manage document localizations"
    localizations: AssetUpdateLocalizationsInput
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateLocalizationDataInput {
    fileName: String
    handle: String
    height: Float
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateLocalizationInput {
    data: AssetUpdateLocalizationDataInput!
    locale: Locale!
}

input AssetUpdateLocalizationsInput {
    "Localizations to create"
    create: [AssetCreateLocalizationInput!]
    "Localizations to delete"
    delete: [Locale!]
    "Localizations to update"
    update: [AssetUpdateLocalizationInput!]
    upsert: [AssetUpsertLocalizationInput!]
}

input AssetUpdateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetConnectInput!]
    "Create and connect multiple Asset documents"
    create: [AssetCreateInput!]
    "Delete multiple Asset documents"
    delete: [AssetWhereUniqueInput!]
    "Disconnect multiple Asset documents"
    disconnect: [AssetWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Asset documents"
    set: [AssetWhereUniqueInput!]
    "Update multiple Asset documents"
    update: [AssetUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Asset documents"
    upsert: [AssetUpsertWithNestedWhereUniqueInput!]
}

input AssetUpdateManyInput {
    fileName: String
    height: Float
    "Optional updates to localizations"
    localizations: AssetUpdateManyLocalizationsInput
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateManyLocalizationDataInput {
    fileName: String
    height: Float
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateManyLocalizationInput {
    data: AssetUpdateManyLocalizationDataInput!
    locale: Locale!
}

input AssetUpdateManyLocalizationsInput {
    "Localizations to update"
    update: [AssetUpdateManyLocalizationInput!]
}

input AssetUpdateManyWithNestedWhereInput {
    "Update many input"
    data: AssetUpdateManyInput!
    "Document search"
    where: AssetWhereInput!
}

input AssetUpdateOneInlineInput {
    "Connect existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
    "Delete currently connected Asset document"
    delete: Boolean
    "Disconnect currently connected Asset document"
    disconnect: Boolean
    "Update single Asset document"
    update: AssetUpdateWithNestedWhereUniqueInput
    "Upsert single Asset document"
    upsert: AssetUpsertWithNestedWhereUniqueInput
}

input AssetUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: AssetUpdateInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

input AssetUpsertInput {
    "Create document if it didn't exist"
    create: AssetCreateInput!
    "Update document if it exists"
    update: AssetUpdateInput!
}

input AssetUpsertLocalizationInput {
    create: AssetCreateLocalizationDataInput!
    locale: Locale!
    update: AssetUpdateLocalizationDataInput!
}

input AssetUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: AssetUpsertInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

"Identifies documents"
input AssetWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    fileName: String
    "All values containing the given string."
    fileName_contains: String
    "All values ending with the given string."
    fileName_ends_with: String
    "All values that are contained in given list."
    fileName_in: [String!]
    "All values that are not equal to given value."
    fileName_not: String
    "All values not containing the given string."
    fileName_not_contains: String
    "All values not ending with the given string"
    fileName_not_ends_with: String
    "All values that are not contained in given list."
    fileName_not_in: [String!]
    "All values not starting with the given string."
    fileName_not_starts_with: String
    "All values starting with the given string."
    fileName_starts_with: String
    handle: String
    "All values containing the given string."
    handle_contains: String
    "All values ending with the given string."
    handle_ends_with: String
    "All values that are contained in given list."
    handle_in: [String!]
    "All values that are not equal to given value."
    handle_not: String
    "All values not containing the given string."
    handle_not_contains: String
    "All values not ending with the given string"
    handle_not_ends_with: String
    "All values that are not contained in given list."
    handle_not_in: [String!]
    "All values not starting with the given string."
    handle_not_starts_with: String
    "All values starting with the given string."
    handle_starts_with: String
    height: Float
    "All values greater than the given value."
    height_gt: Float
    "All values greater than or equal the given value."
    height_gte: Float
    "All values that are contained in given list."
    height_in: [Float!]
    "All values less than the given value."
    height_lt: Float
    "All values less than or equal the given value."
    height_lte: Float
    "All values that are not equal to given value."
    height_not: Float
    "All values that are not contained in given list."
    height_not_in: [Float!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    imageSeo_every: SeoWhereInput
    imageSeo_none: SeoWhereInput
    imageSeo_some: SeoWhereInput
    mimeType: String
    "All values containing the given string."
    mimeType_contains: String
    "All values ending with the given string."
    mimeType_ends_with: String
    "All values that are contained in given list."
    mimeType_in: [String!]
    "All values that are not equal to given value."
    mimeType_not: String
    "All values not containing the given string."
    mimeType_not_contains: String
    "All values not ending with the given string"
    mimeType_not_ends_with: String
    "All values that are not contained in given list."
    mimeType_not_in: [String!]
    "All values not starting with the given string."
    mimeType_not_starts_with: String
    "All values starting with the given string."
    mimeType_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    size: Float
    "All values greater than the given value."
    size_gt: Float
    "All values greater than or equal the given value."
    size_gte: Float
    "All values that are contained in given list."
    size_in: [Float!]
    "All values less than the given value."
    size_lt: Float
    "All values less than or equal the given value."
    size_lte: Float
    "All values that are not equal to given value."
    size_not: Float
    "All values that are not contained in given list."
    size_not_in: [Float!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
    width: Float
    "All values greater than the given value."
    width_gt: Float
    "All values greater than or equal the given value."
    width_gte: Float
    "All values that are contained in given list."
    width_in: [Float!]
    "All values less than the given value."
    width_lt: Float
    "All values less than or equal the given value."
    width_lte: Float
    "All values that are not equal to given value."
    width_not: Float
    "All values that are not contained in given list."
    width_not_in: [Float!]
}

"References Asset record uniquely"
input AssetWhereUniqueInput {
    id: ID
}

input ChapterConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ChapterWhereUniqueInput!
}

input ChapterCopyConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ChapterCopyWhereUniqueInput!
}

input ChapterCopyCreateInput {
    createdAt: DateTime
    nest: ChapterCopyNestCreateManyInlineInput
    slug: String!
    title: String!
    updatedAt: DateTime
}

input ChapterCopyCreateManyInlineInput {
    "Connect multiple existing ChapterCopy documents"
    connect: [ChapterCopyWhereUniqueInput!]
    "Create and connect multiple existing ChapterCopy documents"
    create: [ChapterCopyCreateInput!]
}

input ChapterCopyCreateOneInlineInput {
    "Connect one existing ChapterCopy document"
    connect: ChapterCopyWhereUniqueInput
    "Create and connect one ChapterCopy document"
    create: ChapterCopyCreateInput
}

"Identifies documents"
input ChapterCopyManyWhereInput {
    "Logical AND on all given filters."
    AND: [ChapterCopyWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ChapterCopyWhereInput!]
    "Logical OR on all given filters."
    OR: [ChapterCopyWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input ChapterCopyNestConnectInput {
    Page: PageConnectInput
}

input ChapterCopyNestCreateInput {
    Page: PageCreateInput
}

input ChapterCopyNestCreateManyInlineInput {
    "Connect multiple existing ChapterCopyNest documents"
    connect: [ChapterCopyNestWhereUniqueInput!]
    "Create and connect multiple existing ChapterCopyNest documents"
    create: [ChapterCopyNestCreateInput!]
}

input ChapterCopyNestCreateOneInlineInput {
    "Connect one existing ChapterCopyNest document"
    connect: ChapterCopyNestWhereUniqueInput
    "Create and connect one ChapterCopyNest document"
    create: ChapterCopyNestCreateInput
}

input ChapterCopyNestUpdateInput {
    Page: PageUpdateInput
}

input ChapterCopyNestUpdateManyInlineInput {
    "Connect multiple existing ChapterCopyNest documents"
    connect: [ChapterCopyNestConnectInput!]
    "Create and connect multiple ChapterCopyNest documents"
    create: [ChapterCopyNestCreateInput!]
    "Delete multiple ChapterCopyNest documents"
    delete: [ChapterCopyNestWhereUniqueInput!]
    "Disconnect multiple ChapterCopyNest documents"
    disconnect: [ChapterCopyNestWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ChapterCopyNest documents"
    set: [ChapterCopyNestWhereUniqueInput!]
    "Update multiple ChapterCopyNest documents"
    update: [ChapterCopyNestUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ChapterCopyNest documents"
    upsert: [ChapterCopyNestUpsertWithNestedWhereUniqueInput!]
}

input ChapterCopyNestUpdateManyWithNestedWhereInput {
    Page: PageUpdateManyWithNestedWhereInput
}

input ChapterCopyNestUpdateOneInlineInput {
    "Connect existing ChapterCopyNest document"
    connect: ChapterCopyNestWhereUniqueInput
    "Create and connect one ChapterCopyNest document"
    create: ChapterCopyNestCreateInput
    "Delete currently connected ChapterCopyNest document"
    delete: Boolean
    "Disconnect currently connected ChapterCopyNest document"
    disconnect: Boolean
    "Update single ChapterCopyNest document"
    update: ChapterCopyNestUpdateWithNestedWhereUniqueInput
    "Upsert single ChapterCopyNest document"
    upsert: ChapterCopyNestUpsertWithNestedWhereUniqueInput
}

input ChapterCopyNestUpdateWithNestedWhereUniqueInput {
    Page: PageUpdateWithNestedWhereUniqueInput
}

input ChapterCopyNestUpsertWithNestedWhereUniqueInput {
    Page: PageUpsertWithNestedWhereUniqueInput
}

input ChapterCopyNestWhereInput {
    Page: PageWhereInput
}

input ChapterCopyNestWhereUniqueInput {
    Page: PageWhereUniqueInput
}

input ChapterCopyUpdateInput {
    nest: ChapterCopyNestUpdateManyInlineInput
    slug: String
    title: String
}

input ChapterCopyUpdateManyInlineInput {
    "Connect multiple existing ChapterCopy documents"
    connect: [ChapterCopyConnectInput!]
    "Create and connect multiple ChapterCopy documents"
    create: [ChapterCopyCreateInput!]
    "Delete multiple ChapterCopy documents"
    delete: [ChapterCopyWhereUniqueInput!]
    "Disconnect multiple ChapterCopy documents"
    disconnect: [ChapterCopyWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ChapterCopy documents"
    set: [ChapterCopyWhereUniqueInput!]
    "Update multiple ChapterCopy documents"
    update: [ChapterCopyUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ChapterCopy documents"
    upsert: [ChapterCopyUpsertWithNestedWhereUniqueInput!]
}

input ChapterCopyUpdateManyInput {
    title: String
}

input ChapterCopyUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ChapterCopyUpdateManyInput!
    "Document search"
    where: ChapterCopyWhereInput!
}

input ChapterCopyUpdateOneInlineInput {
    "Connect existing ChapterCopy document"
    connect: ChapterCopyWhereUniqueInput
    "Create and connect one ChapterCopy document"
    create: ChapterCopyCreateInput
    "Delete currently connected ChapterCopy document"
    delete: Boolean
    "Disconnect currently connected ChapterCopy document"
    disconnect: Boolean
    "Update single ChapterCopy document"
    update: ChapterCopyUpdateWithNestedWhereUniqueInput
    "Upsert single ChapterCopy document"
    upsert: ChapterCopyUpsertWithNestedWhereUniqueInput
}

input ChapterCopyUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ChapterCopyUpdateInput!
    "Unique document search"
    where: ChapterCopyWhereUniqueInput!
}

input ChapterCopyUpsertInput {
    "Create document if it didn't exist"
    create: ChapterCopyCreateInput!
    "Update document if it exists"
    update: ChapterCopyUpdateInput!
}

input ChapterCopyUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ChapterCopyUpsertInput!
    "Unique document search"
    where: ChapterCopyWhereUniqueInput!
}

"Identifies documents"
input ChapterCopyWhereInput {
    "Logical AND on all given filters."
    AND: [ChapterCopyWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ChapterCopyWhereInput!]
    "Logical OR on all given filters."
    OR: [ChapterCopyWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References ChapterCopy record uniquely"
input ChapterCopyWhereUniqueInput {
    id: ID
    slug: String
}

input ChapterCreateInput {
    createdAt: DateTime
    navItem: NavigationCreateOneInlineInput
    pages: PageCreateManyInlineInput
    slug: String!
    title: String!
    updatedAt: DateTime
}

input ChapterCreateManyInlineInput {
    "Connect multiple existing Chapter documents"
    connect: [ChapterWhereUniqueInput!]
    "Create and connect multiple existing Chapter documents"
    create: [ChapterCreateInput!]
}

input ChapterCreateOneInlineInput {
    "Connect one existing Chapter document"
    connect: ChapterWhereUniqueInput
    "Create and connect one Chapter document"
    create: ChapterCreateInput
}

"Identifies documents"
input ChapterManyWhereInput {
    "Logical AND on all given filters."
    AND: [ChapterWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ChapterWhereInput!]
    "Logical OR on all given filters."
    OR: [ChapterWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    navItem: NavigationWhereInput
    pages_every: PageWhereInput
    pages_none: PageWhereInput
    pages_some: PageWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input ChapterUpdateInput {
    navItem: NavigationUpdateOneInlineInput
    pages: PageUpdateManyInlineInput
    slug: String
    title: String
}

input ChapterUpdateManyInlineInput {
    "Connect multiple existing Chapter documents"
    connect: [ChapterConnectInput!]
    "Create and connect multiple Chapter documents"
    create: [ChapterCreateInput!]
    "Delete multiple Chapter documents"
    delete: [ChapterWhereUniqueInput!]
    "Disconnect multiple Chapter documents"
    disconnect: [ChapterWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Chapter documents"
    set: [ChapterWhereUniqueInput!]
    "Update multiple Chapter documents"
    update: [ChapterUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Chapter documents"
    upsert: [ChapterUpsertWithNestedWhereUniqueInput!]
}

input ChapterUpdateManyInput {
    title: String
}

input ChapterUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ChapterUpdateManyInput!
    "Document search"
    where: ChapterWhereInput!
}

input ChapterUpdateOneInlineInput {
    "Connect existing Chapter document"
    connect: ChapterWhereUniqueInput
    "Create and connect one Chapter document"
    create: ChapterCreateInput
    "Delete currently connected Chapter document"
    delete: Boolean
    "Disconnect currently connected Chapter document"
    disconnect: Boolean
    "Update single Chapter document"
    update: ChapterUpdateWithNestedWhereUniqueInput
    "Upsert single Chapter document"
    upsert: ChapterUpsertWithNestedWhereUniqueInput
}

input ChapterUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ChapterUpdateInput!
    "Unique document search"
    where: ChapterWhereUniqueInput!
}

input ChapterUpsertInput {
    "Create document if it didn't exist"
    create: ChapterCreateInput!
    "Update document if it exists"
    update: ChapterUpdateInput!
}

input ChapterUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ChapterUpsertInput!
    "Unique document search"
    where: ChapterWhereUniqueInput!
}

"Identifies documents"
input ChapterWhereInput {
    "Logical AND on all given filters."
    AND: [ChapterWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ChapterWhereInput!]
    "Logical OR on all given filters."
    OR: [ChapterWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    navItem: NavigationWhereInput
    pages_every: PageWhereInput
    pages_none: PageWhereInput
    pages_some: PageWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Chapter record uniquely"
input ChapterWhereUniqueInput {
    id: ID
    slug: String
}

"Accepts either HEX or RGBA color value. At least one of hex or rgba value should be passed. If both are passed RGBA is used."
input ColorInput {
    hex: Hex
    rgba: RGBAInput
}

input ConnectPositionInput {
    "Connect document after specified document"
    after: ID
    "Connect document before specified document"
    before: ID
    "Connect document at last position"
    end: Boolean
    "Connect document at first position"
    start: Boolean
}

input DemoModelConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: DemoModelWhereUniqueInput!
}

input DemoModelCreateInput {
    content: RichTextAST!
    createdAt: DateTime
    slug: String!
    subtitle: String
    title: String!
    updatedAt: DateTime
}

input DemoModelCreateManyInlineInput {
    "Connect multiple existing DemoModel documents"
    connect: [DemoModelWhereUniqueInput!]
    "Create and connect multiple existing DemoModel documents"
    create: [DemoModelCreateInput!]
}

input DemoModelCreateOneInlineInput {
    "Connect one existing DemoModel document"
    connect: DemoModelWhereUniqueInput
    "Create and connect one DemoModel document"
    create: DemoModelCreateInput
}

"Identifies documents"
input DemoModelManyWhereInput {
    "Logical AND on all given filters."
    AND: [DemoModelWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [DemoModelWhereInput!]
    "Logical OR on all given filters."
    OR: [DemoModelWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    subtitle: String
    "All values containing the given string."
    subtitle_contains: String
    "All values ending with the given string."
    subtitle_ends_with: String
    "All values that are contained in given list."
    subtitle_in: [String!]
    "All values that are not equal to given value."
    subtitle_not: String
    "All values not containing the given string."
    subtitle_not_contains: String
    "All values not ending with the given string"
    subtitle_not_ends_with: String
    "All values that are not contained in given list."
    subtitle_not_in: [String!]
    "All values not starting with the given string."
    subtitle_not_starts_with: String
    "All values starting with the given string."
    subtitle_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input DemoModelUpdateInput {
    content: RichTextAST
    slug: String
    subtitle: String
    title: String
}

input DemoModelUpdateManyInlineInput {
    "Connect multiple existing DemoModel documents"
    connect: [DemoModelConnectInput!]
    "Create and connect multiple DemoModel documents"
    create: [DemoModelCreateInput!]
    "Delete multiple DemoModel documents"
    delete: [DemoModelWhereUniqueInput!]
    "Disconnect multiple DemoModel documents"
    disconnect: [DemoModelWhereUniqueInput!]
    "Override currently-connected documents with multiple existing DemoModel documents"
    set: [DemoModelWhereUniqueInput!]
    "Update multiple DemoModel documents"
    update: [DemoModelUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple DemoModel documents"
    upsert: [DemoModelUpsertWithNestedWhereUniqueInput!]
}

input DemoModelUpdateManyInput {
    content: RichTextAST
    subtitle: String
    title: String
}

input DemoModelUpdateManyWithNestedWhereInput {
    "Update many input"
    data: DemoModelUpdateManyInput!
    "Document search"
    where: DemoModelWhereInput!
}

input DemoModelUpdateOneInlineInput {
    "Connect existing DemoModel document"
    connect: DemoModelWhereUniqueInput
    "Create and connect one DemoModel document"
    create: DemoModelCreateInput
    "Delete currently connected DemoModel document"
    delete: Boolean
    "Disconnect currently connected DemoModel document"
    disconnect: Boolean
    "Update single DemoModel document"
    update: DemoModelUpdateWithNestedWhereUniqueInput
    "Upsert single DemoModel document"
    upsert: DemoModelUpsertWithNestedWhereUniqueInput
}

input DemoModelUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: DemoModelUpdateInput!
    "Unique document search"
    where: DemoModelWhereUniqueInput!
}

input DemoModelUpsertInput {
    "Create document if it didn't exist"
    create: DemoModelCreateInput!
    "Update document if it exists"
    update: DemoModelUpdateInput!
}

input DemoModelUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: DemoModelUpsertInput!
    "Unique document search"
    where: DemoModelWhereUniqueInput!
}

"Identifies documents"
input DemoModelWhereInput {
    "Logical AND on all given filters."
    AND: [DemoModelWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [DemoModelWhereInput!]
    "Logical OR on all given filters."
    OR: [DemoModelWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    subtitle: String
    "All values containing the given string."
    subtitle_contains: String
    "All values ending with the given string."
    subtitle_ends_with: String
    "All values that are contained in given list."
    subtitle_in: [String!]
    "All values that are not equal to given value."
    subtitle_not: String
    "All values not containing the given string."
    subtitle_not_contains: String
    "All values not ending with the given string"
    subtitle_not_ends_with: String
    "All values that are not contained in given list."
    subtitle_not_in: [String!]
    "All values not starting with the given string."
    subtitle_not_starts_with: String
    "All values starting with the given string."
    subtitle_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References DemoModel record uniquely"
input DemoModelWhereUniqueInput {
    id: ID
    slug: String
}

input DocumentOutputInput {
    """

    Transforms a document into a desired file type.
    See this matrix for format support:

    PDF:    jpg, odp, ods, odt, png, svg, txt, and webp
    DOC:    docx, html, jpg, odt, pdf, png, svg, txt, and webp
    DOCX:    doc, html, jpg, odt, pdf, png, svg, txt, and webp
    ODT:    doc, docx, html, jpg, pdf, png, svg, txt, and webp
    XLS:    jpg, pdf, ods, png, svg, xlsx, and webp
    XLSX:    jpg, pdf, ods, png, svg, xls, and webp
    ODS:    jpg, pdf, png, xls, svg, xlsx, and webp
    PPT:    jpg, odp, pdf, png, svg, pptx, and webp
    PPTX:    jpg, odp, pdf, png, svg, ppt, and webp
    ODP:    jpg, pdf, png, ppt, svg, pptx, and webp
    BMP:    jpg, odp, ods, odt, pdf, png, svg, and webp
    GIF:    jpg, odp, ods, odt, pdf, png, svg, and webp
    JPG:    jpg, odp, ods, odt, pdf, png, svg, and webp
    PNG:    jpg, odp, ods, odt, pdf, png, svg, and webp
    WEBP:    jpg, odp, ods, odt, pdf, png, svg, and webp
    TIFF:    jpg, odp, ods, odt, pdf, png, svg, and webp
    AI:        jpg, odp, ods, odt, pdf, png, svg, and webp
    PSD:    jpg, odp, ods, odt, pdf, png, svg, and webp
    SVG:    jpg, odp, ods, odt, pdf, png, and webp
    HTML:    jpg, odt, pdf, svg, txt, and webp
    TXT:    jpg, html, odt, pdf, svg, and webp
    """
    format: DocumentFileTypes
}

"Transformations for Documents"
input DocumentTransformationInput {
    "Changes the output for the file."
    output: DocumentOutputInput
}

input ExternalLinkConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ExternalLinkWhereUniqueInput!
}

input ExternalLinkCreateInput {
    createdAt: DateTime
    label: String!
    navItem: NavigationCreateOneInlineInput
    updatedAt: DateTime
    url: String!
}

input ExternalLinkCreateManyInlineInput {
    "Connect multiple existing ExternalLink documents"
    connect: [ExternalLinkWhereUniqueInput!]
    "Create and connect multiple existing ExternalLink documents"
    create: [ExternalLinkCreateInput!]
}

input ExternalLinkCreateOneInlineInput {
    "Connect one existing ExternalLink document"
    connect: ExternalLinkWhereUniqueInput
    "Create and connect one ExternalLink document"
    create: ExternalLinkCreateInput
}

"Identifies documents"
input ExternalLinkManyWhereInput {
    "Logical AND on all given filters."
    AND: [ExternalLinkWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ExternalLinkWhereInput!]
    "Logical OR on all given filters."
    OR: [ExternalLinkWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    label: String
    "All values containing the given string."
    label_contains: String
    "All values ending with the given string."
    label_ends_with: String
    "All values that are contained in given list."
    label_in: [String!]
    "All values that are not equal to given value."
    label_not: String
    "All values not containing the given string."
    label_not_contains: String
    "All values not ending with the given string"
    label_not_ends_with: String
    "All values that are not contained in given list."
    label_not_in: [String!]
    "All values not starting with the given string."
    label_not_starts_with: String
    "All values starting with the given string."
    label_starts_with: String
    navItem: NavigationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
    url: String
    "All values containing the given string."
    url_contains: String
    "All values ending with the given string."
    url_ends_with: String
    "All values that are contained in given list."
    url_in: [String!]
    "All values that are not equal to given value."
    url_not: String
    "All values not containing the given string."
    url_not_contains: String
    "All values not ending with the given string"
    url_not_ends_with: String
    "All values that are not contained in given list."
    url_not_in: [String!]
    "All values not starting with the given string."
    url_not_starts_with: String
    "All values starting with the given string."
    url_starts_with: String
}

input ExternalLinkUpdateInput {
    label: String
    navItem: NavigationUpdateOneInlineInput
    url: String
}

input ExternalLinkUpdateManyInlineInput {
    "Connect multiple existing ExternalLink documents"
    connect: [ExternalLinkConnectInput!]
    "Create and connect multiple ExternalLink documents"
    create: [ExternalLinkCreateInput!]
    "Delete multiple ExternalLink documents"
    delete: [ExternalLinkWhereUniqueInput!]
    "Disconnect multiple ExternalLink documents"
    disconnect: [ExternalLinkWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ExternalLink documents"
    set: [ExternalLinkWhereUniqueInput!]
    "Update multiple ExternalLink documents"
    update: [ExternalLinkUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ExternalLink documents"
    upsert: [ExternalLinkUpsertWithNestedWhereUniqueInput!]
}

input ExternalLinkUpdateManyInput {
    label: String
}

input ExternalLinkUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ExternalLinkUpdateManyInput!
    "Document search"
    where: ExternalLinkWhereInput!
}

input ExternalLinkUpdateOneInlineInput {
    "Connect existing ExternalLink document"
    connect: ExternalLinkWhereUniqueInput
    "Create and connect one ExternalLink document"
    create: ExternalLinkCreateInput
    "Delete currently connected ExternalLink document"
    delete: Boolean
    "Disconnect currently connected ExternalLink document"
    disconnect: Boolean
    "Update single ExternalLink document"
    update: ExternalLinkUpdateWithNestedWhereUniqueInput
    "Upsert single ExternalLink document"
    upsert: ExternalLinkUpsertWithNestedWhereUniqueInput
}

input ExternalLinkUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ExternalLinkUpdateInput!
    "Unique document search"
    where: ExternalLinkWhereUniqueInput!
}

input ExternalLinkUpsertInput {
    "Create document if it didn't exist"
    create: ExternalLinkCreateInput!
    "Update document if it exists"
    update: ExternalLinkUpdateInput!
}

input ExternalLinkUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ExternalLinkUpsertInput!
    "Unique document search"
    where: ExternalLinkWhereUniqueInput!
}

"Identifies documents"
input ExternalLinkWhereInput {
    "Logical AND on all given filters."
    AND: [ExternalLinkWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ExternalLinkWhereInput!]
    "Logical OR on all given filters."
    OR: [ExternalLinkWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    label: String
    "All values containing the given string."
    label_contains: String
    "All values ending with the given string."
    label_ends_with: String
    "All values that are contained in given list."
    label_in: [String!]
    "All values that are not equal to given value."
    label_not: String
    "All values not containing the given string."
    label_not_contains: String
    "All values not ending with the given string"
    label_not_ends_with: String
    "All values that are not contained in given list."
    label_not_in: [String!]
    "All values not starting with the given string."
    label_not_starts_with: String
    "All values starting with the given string."
    label_starts_with: String
    navItem: NavigationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
    url: String
    "All values containing the given string."
    url_contains: String
    "All values ending with the given string."
    url_ends_with: String
    "All values that are contained in given list."
    url_in: [String!]
    "All values that are not equal to given value."
    url_not: String
    "All values not containing the given string."
    url_not_contains: String
    "All values not ending with the given string"
    url_not_ends_with: String
    "All values that are not contained in given list."
    url_not_in: [String!]
    "All values not starting with the given string."
    url_not_starts_with: String
    "All values starting with the given string."
    url_starts_with: String
}

"References ExternalLink record uniquely"
input ExternalLinkWhereUniqueInput {
    id: ID
    url: String
}

input ImageResizeInput {
    "The default value for the fit parameter is fit:clip."
    fit: ImageFit
    "The height in pixels to resize the image to. The value must be an integer from 1 to 10000."
    height: Int
    "The width in pixels to resize the image to. The value must be an integer from 1 to 10000."
    width: Int
}

"Transformations for Images"
input ImageTransformationInput {
    "Resizes the image"
    resize: ImageResizeInput
}

"Input for a geolocation point with latitude and longitude"
input LocationInput {
    latitude: Float!
    longitude: Float!
}

input NavItemItemConnectInput {
    Chapter: ChapterConnectInput
    ExternalLink: ExternalLinkConnectInput
    Page: PageConnectInput
}

input NavItemItemCreateInput {
    Chapter: ChapterCreateInput
    ExternalLink: ExternalLinkCreateInput
    Page: PageCreateInput
}

input NavItemItemCreateManyInlineInput {
    "Connect multiple existing NavItemItem documents"
    connect: [NavItemItemWhereUniqueInput!]
    "Create and connect multiple existing NavItemItem documents"
    create: [NavItemItemCreateInput!]
}

input NavItemItemCreateOneInlineInput {
    "Connect one existing NavItemItem document"
    connect: NavItemItemWhereUniqueInput
    "Create and connect one NavItemItem document"
    create: NavItemItemCreateInput
}

input NavItemItemUpdateInput {
    Chapter: ChapterUpdateInput
    ExternalLink: ExternalLinkUpdateInput
    Page: PageUpdateInput
}

input NavItemItemUpdateManyInlineInput {
    "Connect multiple existing NavItemItem documents"
    connect: [NavItemItemConnectInput!]
    "Create and connect multiple NavItemItem documents"
    create: [NavItemItemCreateInput!]
    "Delete multiple NavItemItem documents"
    delete: [NavItemItemWhereUniqueInput!]
    "Disconnect multiple NavItemItem documents"
    disconnect: [NavItemItemWhereUniqueInput!]
    "Override currently-connected documents with multiple existing NavItemItem documents"
    set: [NavItemItemWhereUniqueInput!]
    "Update multiple NavItemItem documents"
    update: [NavItemItemUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple NavItemItem documents"
    upsert: [NavItemItemUpsertWithNestedWhereUniqueInput!]
}

input NavItemItemUpdateManyWithNestedWhereInput {
    Chapter: ChapterUpdateManyWithNestedWhereInput
    ExternalLink: ExternalLinkUpdateManyWithNestedWhereInput
    Page: PageUpdateManyWithNestedWhereInput
}

input NavItemItemUpdateOneInlineInput {
    "Connect existing NavItemItem document"
    connect: NavItemItemWhereUniqueInput
    "Create and connect one NavItemItem document"
    create: NavItemItemCreateInput
    "Delete currently connected NavItemItem document"
    delete: Boolean
    "Disconnect currently connected NavItemItem document"
    disconnect: Boolean
    "Update single NavItemItem document"
    update: NavItemItemUpdateWithNestedWhereUniqueInput
    "Upsert single NavItemItem document"
    upsert: NavItemItemUpsertWithNestedWhereUniqueInput
}

input NavItemItemUpdateWithNestedWhereUniqueInput {
    Chapter: ChapterUpdateWithNestedWhereUniqueInput
    ExternalLink: ExternalLinkUpdateWithNestedWhereUniqueInput
    Page: PageUpdateWithNestedWhereUniqueInput
}

input NavItemItemUpsertWithNestedWhereUniqueInput {
    Chapter: ChapterUpsertWithNestedWhereUniqueInput
    ExternalLink: ExternalLinkUpsertWithNestedWhereUniqueInput
    Page: PageUpsertWithNestedWhereUniqueInput
}

input NavItemItemWhereInput {
    Chapter: ChapterWhereInput
    ExternalLink: ExternalLinkWhereInput
    Page: PageWhereInput
}

input NavItemItemWhereUniqueInput {
    Chapter: ChapterWhereUniqueInput
    ExternalLink: ExternalLinkWhereUniqueInput
    Page: PageWhereUniqueInput
}

input NavigationConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: NavigationWhereUniqueInput!
}

input NavigationCreateInput {
    createdAt: DateTime
    linkTo: NavItemItemCreateManyInlineInput
    updatedAt: DateTime
}

input NavigationCreateManyInlineInput {
    "Connect multiple existing Navigation documents"
    connect: [NavigationWhereUniqueInput!]
    "Create and connect multiple existing Navigation documents"
    create: [NavigationCreateInput!]
}

input NavigationCreateOneInlineInput {
    "Connect one existing Navigation document"
    connect: NavigationWhereUniqueInput
    "Create and connect one Navigation document"
    create: NavigationCreateInput
}

"Identifies documents"
input NavigationManyWhereInput {
    "Logical AND on all given filters."
    AND: [NavigationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [NavigationWhereInput!]
    "Logical OR on all given filters."
    OR: [NavigationWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input NavigationUpdateInput {
    linkTo: NavItemItemUpdateManyInlineInput
}

input NavigationUpdateManyInlineInput {
    "Connect multiple existing Navigation documents"
    connect: [NavigationConnectInput!]
    "Create and connect multiple Navigation documents"
    create: [NavigationCreateInput!]
    "Delete multiple Navigation documents"
    delete: [NavigationWhereUniqueInput!]
    "Disconnect multiple Navigation documents"
    disconnect: [NavigationWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Navigation documents"
    set: [NavigationWhereUniqueInput!]
    "Update multiple Navigation documents"
    update: [NavigationUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Navigation documents"
    upsert: [NavigationUpsertWithNestedWhereUniqueInput!]
}

input NavigationUpdateManyInput {
    "No fields in updateMany data input"
    _: String
}

input NavigationUpdateManyWithNestedWhereInput {
    "Update many input"
    data: NavigationUpdateManyInput!
    "Document search"
    where: NavigationWhereInput!
}

input NavigationUpdateOneInlineInput {
    "Connect existing Navigation document"
    connect: NavigationWhereUniqueInput
    "Create and connect one Navigation document"
    create: NavigationCreateInput
    "Delete currently connected Navigation document"
    delete: Boolean
    "Disconnect currently connected Navigation document"
    disconnect: Boolean
    "Update single Navigation document"
    update: NavigationUpdateWithNestedWhereUniqueInput
    "Upsert single Navigation document"
    upsert: NavigationUpsertWithNestedWhereUniqueInput
}

input NavigationUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: NavigationUpdateInput!
    "Unique document search"
    where: NavigationWhereUniqueInput!
}

input NavigationUpsertInput {
    "Create document if it didn't exist"
    create: NavigationCreateInput!
    "Update document if it exists"
    update: NavigationUpdateInput!
}

input NavigationUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: NavigationUpsertInput!
    "Unique document search"
    where: NavigationWhereUniqueInput!
}

"Identifies documents"
input NavigationWhereInput {
    "Logical AND on all given filters."
    AND: [NavigationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [NavigationWhereInput!]
    "Logical OR on all given filters."
    OR: [NavigationWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Navigation record uniquely"
input NavigationWhereUniqueInput {
    id: ID
}

input PageConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: PageWhereUniqueInput!
}

input PageCreateInput {
    chapter: ChapterCreateOneInlineInput
    chapters: ChapterCopyCreateManyInlineInput
    content: RichTextAST
    createdAt: DateTime
    navItem: NavigationCreateOneInlineInput
    seo: SeoCreateOneInlineInput
    slug: String!
    title: String!
    updatedAt: DateTime
}

input PageCreateManyInlineInput {
    "Connect multiple existing Page documents"
    connect: [PageWhereUniqueInput!]
    "Create and connect multiple existing Page documents"
    create: [PageCreateInput!]
}

input PageCreateOneInlineInput {
    "Connect one existing Page document"
    connect: PageWhereUniqueInput
    "Create and connect one Page document"
    create: PageCreateInput
}

"Identifies documents"
input PageManyWhereInput {
    "Logical AND on all given filters."
    AND: [PageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [PageWhereInput!]
    "Logical OR on all given filters."
    OR: [PageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    chapter: ChapterWhereInput
    chapters_every: ChapterCopyWhereInput
    chapters_none: ChapterCopyWhereInput
    chapters_some: ChapterCopyWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    navItem: NavigationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    seo: SeoWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input PageUpdateInput {
    chapter: ChapterUpdateOneInlineInput
    chapters: ChapterCopyUpdateManyInlineInput
    content: RichTextAST
    navItem: NavigationUpdateOneInlineInput
    seo: SeoUpdateOneInlineInput
    slug: String
    title: String
}

input PageUpdateManyInlineInput {
    "Connect multiple existing Page documents"
    connect: [PageConnectInput!]
    "Create and connect multiple Page documents"
    create: [PageCreateInput!]
    "Delete multiple Page documents"
    delete: [PageWhereUniqueInput!]
    "Disconnect multiple Page documents"
    disconnect: [PageWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Page documents"
    set: [PageWhereUniqueInput!]
    "Update multiple Page documents"
    update: [PageUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Page documents"
    upsert: [PageUpsertWithNestedWhereUniqueInput!]
}

input PageUpdateManyInput {
    content: RichTextAST
    title: String
}

input PageUpdateManyWithNestedWhereInput {
    "Update many input"
    data: PageUpdateManyInput!
    "Document search"
    where: PageWhereInput!
}

input PageUpdateOneInlineInput {
    "Connect existing Page document"
    connect: PageWhereUniqueInput
    "Create and connect one Page document"
    create: PageCreateInput
    "Delete currently connected Page document"
    delete: Boolean
    "Disconnect currently connected Page document"
    disconnect: Boolean
    "Update single Page document"
    update: PageUpdateWithNestedWhereUniqueInput
    "Upsert single Page document"
    upsert: PageUpsertWithNestedWhereUniqueInput
}

input PageUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: PageUpdateInput!
    "Unique document search"
    where: PageWhereUniqueInput!
}

input PageUpsertInput {
    "Create document if it didn't exist"
    create: PageCreateInput!
    "Update document if it exists"
    update: PageUpdateInput!
}

input PageUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: PageUpsertInput!
    "Unique document search"
    where: PageWhereUniqueInput!
}

"Identifies documents"
input PageWhereInput {
    "Logical AND on all given filters."
    AND: [PageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [PageWhereInput!]
    "Logical OR on all given filters."
    OR: [PageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    chapter: ChapterWhereInput
    chapters_every: ChapterCopyWhereInput
    chapters_none: ChapterCopyWhereInput
    chapters_some: ChapterCopyWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    navItem: NavigationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    seo: SeoWhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String!]
    "All values that are not equal to given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String!]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Page record uniquely"
input PageWhereUniqueInput {
    id: ID
    slug: String
}

input PublishLocaleInput {
    "Locales to publish"
    locale: Locale!
    "Stages to publish selected locales to"
    stages: [Stage!]!
}

"Input type representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
input RGBAInput {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

input ScheduledOperationConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ScheduledOperationWhereUniqueInput!
}

input ScheduledOperationCreateManyInlineInput {
    "Connect multiple existing ScheduledOperation documents"
    connect: [ScheduledOperationWhereUniqueInput!]
}

input ScheduledOperationCreateOneInlineInput {
    "Connect one existing ScheduledOperation document"
    connect: ScheduledOperationWhereUniqueInput
}

"Identifies documents"
input ScheduledOperationManyWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledOperationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledOperationWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledOperationWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String!]
    "All values that are not equal to given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String!]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    release: ScheduledReleaseWhereInput
    status: ScheduledOperationStatus
    "All values that are contained in given list."
    status_in: [ScheduledOperationStatus!]
    "All values that are not equal to given value."
    status_not: ScheduledOperationStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledOperationStatus!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input ScheduledOperationUpdateManyInlineInput {
    "Connect multiple existing ScheduledOperation documents"
    connect: [ScheduledOperationConnectInput!]
    "Disconnect multiple ScheduledOperation documents"
    disconnect: [ScheduledOperationWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ScheduledOperation documents"
    set: [ScheduledOperationWhereUniqueInput!]
}

input ScheduledOperationUpdateOneInlineInput {
    "Connect existing ScheduledOperation document"
    connect: ScheduledOperationWhereUniqueInput
    "Disconnect currently connected ScheduledOperation document"
    disconnect: Boolean
}

"Identifies documents"
input ScheduledOperationWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledOperationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledOperationWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledOperationWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String!]
    "All values that are not equal to given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String!]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    release: ScheduledReleaseWhereInput
    status: ScheduledOperationStatus
    "All values that are contained in given list."
    status_in: [ScheduledOperationStatus!]
    "All values that are not equal to given value."
    status_not: ScheduledOperationStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledOperationStatus!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References ScheduledOperation record uniquely"
input ScheduledOperationWhereUniqueInput {
    id: ID
}

input ScheduledReleaseConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ScheduledReleaseWhereUniqueInput!
}

input ScheduledReleaseCreateInput {
    createdAt: DateTime
    description: String
    errorMessage: String
    isActive: Boolean = true
    releaseAt: DateTime
    title: String
    updatedAt: DateTime
}

input ScheduledReleaseCreateManyInlineInput {
    "Connect multiple existing ScheduledRelease documents"
    connect: [ScheduledReleaseWhereUniqueInput!]
    "Create and connect multiple existing ScheduledRelease documents"
    create: [ScheduledReleaseCreateInput!]
}

input ScheduledReleaseCreateOneInlineInput {
    "Connect one existing ScheduledRelease document"
    connect: ScheduledReleaseWhereUniqueInput
    "Create and connect one ScheduledRelease document"
    create: ScheduledReleaseCreateInput
}

"Identifies documents"
input ScheduledReleaseManyWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledReleaseWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledReleaseWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledReleaseWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String!]
    "All values that are not equal to given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String!]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "All values that are not equal to given value."
    isActive_not: Boolean
    isImplicit: Boolean
    "All values that are not equal to given value."
    isImplicit_not: Boolean
    operations_every: ScheduledOperationWhereInput
    operations_none: ScheduledOperationWhereInput
    operations_some: ScheduledOperationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    releaseAt: DateTime
    "All values greater than the given value."
    releaseAt_gt: DateTime
    "All values greater than or equal the given value."
    releaseAt_gte: DateTime
    "All values that are contained in given list."
    releaseAt_in: [DateTime!]
    "All values less than the given value."
    releaseAt_lt: DateTime
    "All values less than or equal the given value."
    releaseAt_lte: DateTime
    "All values that are not equal to given value."
    releaseAt_not: DateTime
    "All values that are not contained in given list."
    releaseAt_not_in: [DateTime!]
    status: ScheduledReleaseStatus
    "All values that are contained in given list."
    status_in: [ScheduledReleaseStatus!]
    "All values that are not equal to given value."
    status_not: ScheduledReleaseStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledReleaseStatus!]
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input ScheduledReleaseUpdateInput {
    description: String
    errorMessage: String
    isActive: Boolean
    releaseAt: DateTime
    title: String
}

input ScheduledReleaseUpdateManyInlineInput {
    "Connect multiple existing ScheduledRelease documents"
    connect: [ScheduledReleaseConnectInput!]
    "Create and connect multiple ScheduledRelease documents"
    create: [ScheduledReleaseCreateInput!]
    "Delete multiple ScheduledRelease documents"
    delete: [ScheduledReleaseWhereUniqueInput!]
    "Disconnect multiple ScheduledRelease documents"
    disconnect: [ScheduledReleaseWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ScheduledRelease documents"
    set: [ScheduledReleaseWhereUniqueInput!]
    "Update multiple ScheduledRelease documents"
    update: [ScheduledReleaseUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ScheduledRelease documents"
    upsert: [ScheduledReleaseUpsertWithNestedWhereUniqueInput!]
}

input ScheduledReleaseUpdateManyInput {
    description: String
    errorMessage: String
    isActive: Boolean
    releaseAt: DateTime
    title: String
}

input ScheduledReleaseUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ScheduledReleaseUpdateManyInput!
    "Document search"
    where: ScheduledReleaseWhereInput!
}

input ScheduledReleaseUpdateOneInlineInput {
    "Connect existing ScheduledRelease document"
    connect: ScheduledReleaseWhereUniqueInput
    "Create and connect one ScheduledRelease document"
    create: ScheduledReleaseCreateInput
    "Delete currently connected ScheduledRelease document"
    delete: Boolean
    "Disconnect currently connected ScheduledRelease document"
    disconnect: Boolean
    "Update single ScheduledRelease document"
    update: ScheduledReleaseUpdateWithNestedWhereUniqueInput
    "Upsert single ScheduledRelease document"
    upsert: ScheduledReleaseUpsertWithNestedWhereUniqueInput
}

input ScheduledReleaseUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ScheduledReleaseUpdateInput!
    "Unique document search"
    where: ScheduledReleaseWhereUniqueInput!
}

input ScheduledReleaseUpsertInput {
    "Create document if it didn't exist"
    create: ScheduledReleaseCreateInput!
    "Update document if it exists"
    update: ScheduledReleaseUpdateInput!
}

input ScheduledReleaseUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ScheduledReleaseUpsertInput!
    "Unique document search"
    where: ScheduledReleaseWhereUniqueInput!
}

"Identifies documents"
input ScheduledReleaseWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledReleaseWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledReleaseWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledReleaseWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String!]
    "All values that are not equal to given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String!]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "All values that are not equal to given value."
    isActive_not: Boolean
    isImplicit: Boolean
    "All values that are not equal to given value."
    isImplicit_not: Boolean
    operations_every: ScheduledOperationWhereInput
    operations_none: ScheduledOperationWhereInput
    operations_some: ScheduledOperationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    releaseAt: DateTime
    "All values greater than the given value."
    releaseAt_gt: DateTime
    "All values greater than or equal the given value."
    releaseAt_gte: DateTime
    "All values that are contained in given list."
    releaseAt_in: [DateTime!]
    "All values less than the given value."
    releaseAt_lt: DateTime
    "All values less than or equal the given value."
    releaseAt_lte: DateTime
    "All values that are not equal to given value."
    releaseAt_not: DateTime
    "All values that are not contained in given list."
    releaseAt_not_in: [DateTime!]
    status: ScheduledReleaseStatus
    "All values that are contained in given list."
    status_in: [ScheduledReleaseStatus!]
    "All values that are not equal to given value."
    status_not: ScheduledReleaseStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledReleaseStatus!]
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References ScheduledRelease record uniquely"
input ScheduledReleaseWhereUniqueInput {
    id: ID
}

input SeoConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: SeoWhereUniqueInput!
}

input SeoCreateInput {
    ckzd6b9yn15d601xr1dei73tv: PageCreateManyInlineInput
    createdAt: DateTime
    description: String
    image: AssetCreateOneInlineInput
    noindex: Boolean
    title: String
    updatedAt: DateTime
}

input SeoCreateManyInlineInput {
    "Connect multiple existing Seo documents"
    connect: [SeoWhereUniqueInput!]
    "Create and connect multiple existing Seo documents"
    create: [SeoCreateInput!]
}

input SeoCreateOneInlineInput {
    "Connect one existing Seo document"
    connect: SeoWhereUniqueInput
    "Create and connect one Seo document"
    create: SeoCreateInput
}

"Identifies documents"
input SeoManyWhereInput {
    "Logical AND on all given filters."
    AND: [SeoWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [SeoWhereInput!]
    "Logical OR on all given filters."
    OR: [SeoWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    image: AssetWhereInput
    noindex: Boolean
    "All values that are not equal to given value."
    noindex_not: Boolean
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input SeoUpdateInput {
    ckzd6b9yn15d601xr1dei73tv: PageUpdateManyInlineInput
    description: String
    image: AssetUpdateOneInlineInput
    noindex: Boolean
    title: String
}

input SeoUpdateManyInlineInput {
    "Connect multiple existing Seo documents"
    connect: [SeoConnectInput!]
    "Create and connect multiple Seo documents"
    create: [SeoCreateInput!]
    "Delete multiple Seo documents"
    delete: [SeoWhereUniqueInput!]
    "Disconnect multiple Seo documents"
    disconnect: [SeoWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Seo documents"
    set: [SeoWhereUniqueInput!]
    "Update multiple Seo documents"
    update: [SeoUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Seo documents"
    upsert: [SeoUpsertWithNestedWhereUniqueInput!]
}

input SeoUpdateManyInput {
    description: String
    noindex: Boolean
    title: String
}

input SeoUpdateManyWithNestedWhereInput {
    "Update many input"
    data: SeoUpdateManyInput!
    "Document search"
    where: SeoWhereInput!
}

input SeoUpdateOneInlineInput {
    "Connect existing Seo document"
    connect: SeoWhereUniqueInput
    "Create and connect one Seo document"
    create: SeoCreateInput
    "Delete currently connected Seo document"
    delete: Boolean
    "Disconnect currently connected Seo document"
    disconnect: Boolean
    "Update single Seo document"
    update: SeoUpdateWithNestedWhereUniqueInput
    "Upsert single Seo document"
    upsert: SeoUpsertWithNestedWhereUniqueInput
}

input SeoUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: SeoUpdateInput!
    "Unique document search"
    where: SeoWhereUniqueInput!
}

input SeoUpsertInput {
    "Create document if it didn't exist"
    create: SeoCreateInput!
    "Update document if it exists"
    update: SeoUpdateInput!
}

input SeoUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: SeoUpsertInput!
    "Unique document search"
    where: SeoWhereUniqueInput!
}

"Identifies documents"
input SeoWhereInput {
    "Logical AND on all given filters."
    AND: [SeoWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [SeoWhereInput!]
    "Logical OR on all given filters."
    OR: [SeoWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    image: AssetWhereInput
    noindex: Boolean
    "All values that are not equal to given value."
    noindex_not: Boolean
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Seo record uniquely"
input SeoWhereUniqueInput {
    id: ID
}

input UnpublishLocaleInput {
    "Locales to unpublish"
    locale: Locale!
    "Stages to unpublish selected locales from"
    stages: [Stage!]!
}

input UserConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: UserWhereUniqueInput!
}

input UserCreateManyInlineInput {
    "Connect multiple existing User documents"
    connect: [UserWhereUniqueInput!]
}

input UserCreateOneInlineInput {
    "Connect one existing User document"
    connect: UserWhereUniqueInput
}

"Identifies documents"
input UserManyWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "All values that are not equal to given value."
    isActive_not: Boolean
    kind: UserKind
    "All values that are contained in given list."
    kind_in: [UserKind!]
    "All values that are not equal to given value."
    kind_not: UserKind
    "All values that are not contained in given list."
    kind_not_in: [UserKind!]
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    picture: String
    "All values containing the given string."
    picture_contains: String
    "All values ending with the given string."
    picture_ends_with: String
    "All values that are contained in given list."
    picture_in: [String!]
    "All values that are not equal to given value."
    picture_not: String
    "All values not containing the given string."
    picture_not_contains: String
    "All values not ending with the given string"
    picture_not_ends_with: String
    "All values that are not contained in given list."
    picture_not_in: [String!]
    "All values not starting with the given string."
    picture_not_starts_with: String
    "All values starting with the given string."
    picture_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

input UserUpdateManyInlineInput {
    "Connect multiple existing User documents"
    connect: [UserConnectInput!]
    "Disconnect multiple User documents"
    disconnect: [UserWhereUniqueInput!]
    "Override currently-connected documents with multiple existing User documents"
    set: [UserWhereUniqueInput!]
}

input UserUpdateOneInlineInput {
    "Connect existing User document"
    connect: UserWhereUniqueInput
    "Disconnect currently connected User document"
    disconnect: Boolean
}

"Identifies documents"
input UserWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "All values that are not equal to given value."
    isActive_not: Boolean
    kind: UserKind
    "All values that are contained in given list."
    kind_in: [UserKind!]
    "All values that are not equal to given value."
    kind_not: UserKind
    "All values that are not contained in given list."
    kind_not_in: [UserKind!]
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    picture: String
    "All values containing the given string."
    picture_contains: String
    "All values ending with the given string."
    picture_ends_with: String
    "All values that are contained in given list."
    picture_in: [String!]
    "All values that are not equal to given value."
    picture_not: String
    "All values not containing the given string."
    picture_not_contains: String
    "All values not ending with the given string"
    picture_not_ends_with: String
    "All values that are not contained in given list."
    picture_not_in: [String!]
    "All values not starting with the given string."
    picture_not_starts_with: String
    "All values starting with the given string."
    picture_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

"References User record uniquely"
input UserWhereUniqueInput {
    id: ID
}

input VersionWhereInput {
    id: ID!
    revision: Int!
    stage: Stage!
}
